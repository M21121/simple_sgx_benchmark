=== Directory Structure ===
.
├── App
│   └── App.cpp
├── Enclave
│   ├── Enclave.config.xml
│   ├── Enclave.cpp
│   ├── Enclave.edl
│   └── Enclave_private.pem
└── Makefile

3 directories, 6 files

=== Code Files ===


### File: ./App/App.cpp ###

// App/App.cpp
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sgx_urts.h>
#include "Enclave_u.h"

#define ENCLAVE_FILENAME "enclave.signed.so"
#define NUM_ITERATIONS 1000000

void ocall_do_nothing() {
    // Intentionally empty. We only want to measure the cost of calling it.
    return;
}

int main() {
    sgx_enclave_id_t eid = 0;
    sgx_status_t ret = SGX_SUCCESS;
    sgx_launch_token_t token = {0};
    int updated = 0;

    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &eid, NULL);
    if (ret != SGX_SUCCESS) {
        printf("Failed to create enclave: %d\n", ret);
        return -1;
    }

    printf("SGX Performance Benchmark Suite\n");
    printf("Iterations: %d\n\n", NUM_ITERATIONS);

    // Memory fence comparison benchmark
    printf("=== Memory Fence Benchmark ===\n");
    uint64_t cycles_without_fence, cycles_with_mfence, cycles_with_lfence;

    ecall_benchmark_without_mfence(eid, &cycles_without_fence, NUM_ITERATIONS);
    ecall_benchmark_with_mfence(eid, &cycles_with_mfence, NUM_ITERATIONS);
    ecall_benchmark_with_lfence(eid, &cycles_with_lfence, NUM_ITERATIONS);

    double avg_without = (double)cycles_without_fence / NUM_ITERATIONS;
    double avg_mfence = (double)cycles_with_mfence / NUM_ITERATIONS;
    double avg_lfence = (double)cycles_with_lfence / NUM_ITERATIONS;
    double mfence_overhead = avg_mfence - avg_without;
    double lfence_overhead = avg_lfence - avg_without;

    printf("Without fence: %lu cycles (%.2f cycles/iter)\n", cycles_without_fence, avg_without);
    printf("With MFENCE:   %lu cycles (%.2f cycles/iter)\n", cycles_with_mfence, avg_mfence);
    printf("With LFENCE:   %lu cycles (%.2f cycles/iter)\n", cycles_with_lfence, avg_lfence);
    printf("MFENCE overhead: %.2f cycles/iter (%.2f%%)\n", mfence_overhead, (mfence_overhead/avg_without)*100.0);
    printf("LFENCE overhead: %.2f cycles/iter (%.2f%%)\n\n", lfence_overhead, (lfence_overhead/avg_without)*100.0);

    // CPU-intensive workload
    printf("=== CPU Intensive Workload ===\n");
    uint64_t cpu_cycles;
    ecall_cpu_intensive(eid, &cpu_cycles, NUM_ITERATIONS/10);
    printf("CPU workload: %lu cycles (%.2f cycles/iter)\n\n", cpu_cycles, (double)cpu_cycles/(NUM_ITERATIONS/10));

    // Memory workload
    printf("=== Memory Access Workload ===\n");
    uint64_t mem_cycles;
    ecall_memory_workload(eid, &mem_cycles, NUM_ITERATIONS/100);
    printf("Memory workload: %lu cycles (%.2f cycles/iter)\n\n", mem_cycles, (double)mem_cycles/(NUM_ITERATIONS/100));

    // Crypto workload
    printf("=== Cryptographic Workload ===\n");
    uint64_t crypto_cycles;
    ecall_crypto_workload(eid, &crypto_cycles, 1000);
    printf("Crypto workload: %lu cycles (%.2f cycles/iter)\n\n", crypto_cycles, (double)crypto_cycles/1000);

    // System call overhead simulation
    printf("=== System Call Overhead ===\n");
    uint64_t syscall_cycles;
    ecall_syscall_overhead(eid, &syscall_cycles, 10000);
    printf("Syscall overhead: %lu cycles (%.2f cycles/iter)\n\n", syscall_cycles, (double)syscall_cycles/10000);

    // OCALL Benchmark
    printf("=== OCALL Benchmark ===\n");
    uint64_t ocall_cycles;
    int ocall_iterations = 10000;
    ecall_ocall_benchmark(eid, &ocall_cycles, ocall_iterations);
    printf("OCALL transition: %lu cycles (%.2f cycles/iter)\n\n", ocall_cycles, (double)ocall_cycles / ocall_iterations);

    sgx_destroy_enclave(eid);
    return 0;
}

-------------------


### File: ./Enclave/Enclave.cpp ###

// Enclave/Enclave.cpp
#include "Enclave_t.h"
#include <stdint.h>
#include <string.h>

static __inline__ uint64_t rdtsc(void) {
    __builtin_ia32_lfence();
    unsigned int lo, hi;
    __asm__ __volatile__("rdtsc" : "=a"(lo), "=d"(hi));
    __builtin_ia32_lfence();
    return ((uint64_t)hi << 32) | lo;
}

static volatile int dummy_work(int x) {
    return x * 2 + 1;
}

// Original benchmarks
void ecall_benchmark_without_mfence(uint64_t* total_cycles, int iterations) {
    uint64_t start, end;
    volatile int result = 0;

    start = rdtsc();
    for (int i = 0; i < iterations; i++) {
        result += dummy_work(i);
    }
    end = rdtsc();
    *total_cycles = end - start;
}

void ecall_benchmark_with_mfence(uint64_t* total_cycles, int iterations) {
    uint64_t start, end;
    volatile int result = 0;

    start = rdtsc();
    for (int i = 0; i < iterations; i++) {
        result += dummy_work(i);
        __asm__ __volatile__("mfence" ::: "memory");
    }
    end = rdtsc();
    *total_cycles = end - start;
}

// CPU-intensive workload with mathematical operations
void ecall_cpu_intensive(uint64_t* total_cycles, int iterations) {
    uint64_t start, end;
    volatile double result = 1.0;

    start = rdtsc();
    for (int i = 0; i < iterations; i++) {
        result *= 1.000001;
        result += (double)(i % 1000) / 1000.0;
        result = result > 2.0 ? result / 2.0 : result;
    }
    end = rdtsc();
    *total_cycles = end - start;
}

// Memory access workload
void ecall_memory_workload(uint64_t* total_cycles, int iterations) {
    uint64_t start, end;
    const int buffer_size = 1024 * 1024; // 1MB
    volatile char* buffer = (volatile char*)malloc(buffer_size);

    if (!buffer) {
        *total_cycles = 0;
        return;
    }

    start = rdtsc();
    for (int i = 0; i < iterations; i++) {
        // Sequential access
        for (int j = 0; j < buffer_size; j += 64) { // Cache line size
            buffer[j] = (char)(i + j);
        }
        // Random access pattern
        for (int j = 0; j < 1000; j++) {
            int idx = (i * 1337 + j * 7919) % buffer_size;
            buffer[idx] = (char)(buffer[idx] + 1);
        }
    }
    end = rdtsc();

    free((void*)buffer);
    *total_cycles = end - start;
}

// Simple hash function for crypto workload
static uint32_t simple_hash(const char* data, int len) {
    uint32_t hash = 5381;
    for (int i = 0; i < len; i++) {
        hash = ((hash << 5) + hash) + data[i];
    }
    return hash;
}

// Cryptographic workload
void ecall_crypto_workload(uint64_t* total_cycles, int iterations) {
    uint64_t start, end;
    char data[256];
    volatile uint32_t result = 0;

    // Initialize data
    for (int i = 0; i < 256; i++) {
        data[i] = (char)(i ^ 0xAA);
    }

    start = rdtsc();
    for (int i = 0; i < iterations; i++) {
        // Multiple hash rounds
        for (int round = 0; round < 100; round++) {
            result ^= simple_hash(data, 256);
            // Modify data for next round
            data[round % 256] = (char)(result & 0xFF);
        }
    }
    end = rdtsc();
    *total_cycles = end - start;
}

// System call overhead simulation
void ecall_syscall_overhead(uint64_t* total_cycles, int iterations) {
    uint64_t start, end;
    volatile int result = 0;

    start = rdtsc();
    for (int i = 0; i < iterations; i++) {
        // Simulate enclave exit/entry overhead with memory barriers
        __asm__ __volatile__("mfence" ::: "memory");
        result += dummy_work(i);
        __asm__ __volatile__("mfence" ::: "memory");
        __asm__ __volatile__("lfence" ::: "memory");
    }
    end = rdtsc();
    *total_cycles = end - start;
}

void ecall_ocall_benchmark(uint64_t* total_cycles, int iterations) {
    uint64_t start, end;

    start = rdtsc();
    for (int i = 0; i < iterations; i++) {
        // This makes the enclave call out to the untrusted App
        ocall_do_nothing();
    }
    end = rdtsc();

    *total_cycles = end - start;
}

void ecall_benchmark_with_lfence(uint64_t* total_cycles, int iterations) {
    uint64_t start, end;
    volatile int result = 0;

    start = rdtsc();
    for (int i = 0; i < iterations; i++) {
        result += dummy_work(i);
        __asm__ __volatile__("lfence" ::: "memory");
    }
    end = rdtsc();
    *total_cycles = end - start;
}

-------------------


### File: ./Enclave/Enclave.edl ###

enclave {
    untrusted {
        void ocall_do_nothing();
    };

    trusted {
        public void ecall_benchmark_without_mfence([out] uint64_t* total_cycles, int iterations);
        public void ecall_benchmark_with_mfence([out] uint64_t* total_cycles, int iterations);
        public void ecall_benchmark_with_lfence([out] uint64_t* total_cycles, int iterations);
        public void ecall_cpu_intensive([out] uint64_t* total_cycles, int iterations);
        public void ecall_memory_workload([out] uint64_t* total_cycles, int iterations);
        public void ecall_crypto_workload([out] uint64_t* total_cycles, int iterations);
        public void ecall_syscall_overhead([out] uint64_t* total_cycles, int iterations);
        public void ecall_ocall_benchmark([out] uint64_t* total_cycles, int iterations);
    };
};

-------------------


### File: Makefile ###

# Makefile
SGX_SDK ?= /opt/intel/sgxsdk
SGX_MODE ?= HW
SGX_ARCH ?= x64
SGX_DEBUG ?= 1

ifeq ($(SGX_ARCH), x86)
	SGX_COMMON_CFLAGS := -m32
	SGX_LIBRARY_PATH := $(SGX_SDK)/lib
	SGX_ENCLAVE_SIGNER := $(SGX_SDK)/bin/x86/sgx_sign
	SGX_EDGER8R := $(SGX_SDK)/bin/x86/sgx_edger8r
else
	SGX_COMMON_CFLAGS := -m64
	SGX_LIBRARY_PATH := $(SGX_SDK)/lib64
	SGX_ENCLAVE_SIGNER := $(SGX_SDK)/bin/x64/sgx_sign
	SGX_EDGER8R := $(SGX_SDK)/bin/x64/sgx_edger8r
endif

ifeq ($(SGX_DEBUG), 1)
	SGX_COMMON_CFLAGS += -O0 -g
else
	SGX_COMMON_CFLAGS += -O2
endif

SGX_COMMON_CFLAGS += -Wall -Wextra -fPIC
SGX_COMMON_CXXFLAGS := $(SGX_COMMON_CFLAGS) -std=c++11

App_Cpp_Files := App/App.cpp
App_Include_Paths := -IApp -I$(SGX_SDK)/include

App_C_Flags := $(SGX_COMMON_CFLAGS) $(App_Include_Paths)
App_Cpp_Flags := $(SGX_COMMON_CXXFLAGS) $(App_Include_Paths)

# Force use of system linker and avoid math libraries
ifeq ($(SGX_MODE), HW)
	App_Link_Flags := -fuse-ld=bfd -L$(SGX_LIBRARY_PATH) -lsgx_urts -lsgx_uae_service -lpthread -ldl -Wl,--as-needed
else
	App_Link_Flags := -fuse-ld=bfd -L$(SGX_LIBRARY_PATH) -lsgx_urts_sim -lsgx_uae_service_sim -lpthread -ldl -Wl,--as-needed
endif

App_Cpp_Objects := $(App_Cpp_Files:.cpp=.o)

Enclave_Cpp_Files := Enclave/Enclave.cpp
Enclave_Include_Paths := -IEnclave -I$(SGX_SDK)/include -I$(SGX_SDK)/include/tlibc -I$(SGX_SDK)/include/libcxx

Enclave_C_Flags := $(SGX_COMMON_CFLAGS) -nostdinc -fvisibility=hidden -fpie $(Enclave_Include_Paths)
Enclave_Cpp_Flags := $(SGX_COMMON_CXXFLAGS) -nostdinc++ $(Enclave_Include_Paths)

ifeq ($(SGX_MODE), HW)
	Enclave_Link_Flags := -Wl,--no-undefined -nostdlib -nodefaultlibs -nostartfiles -L$(SGX_LIBRARY_PATH) \
		-Wl,--whole-archive -lsgx_trts -Wl,--no-whole-archive \
		-Wl,--start-group -lsgx_tstdc -lsgx_tcxx -lsgx_tcrypto -lsgx_tservice -Wl,--end-group \
		-Wl,-Bstatic -Wl,-Bsymbolic -Wl,--no-undefined \
		-Wl,-pie,-eenclave_entry -Wl,--export-dynamic \
		-Wl,--defsym,__ImageBase=0
else
	Enclave_Link_Flags := -Wl,--no-undefined -nostdlib -nodefaultlibs -nostartfiles -L$(SGX_LIBRARY_PATH) \
		-Wl,--whole-archive -lsgx_trts_sim -Wl,--no-whole-archive \
		-Wl,--start-group -lsgx_tstdc -lsgx_tcxx -lsgx_tcrypto -lsgx_tservice_sim -Wl,--end-group \
		-Wl,-Bstatic -Wl,-Bsymbolic -Wl,--no-undefined \
		-Wl,-pie,-eenclave_entry -Wl,--export-dynamic \
		-Wl,--defsym,__ImageBase=0
endif

Enclave_Cpp_Objects := $(Enclave_Cpp_Files:.cpp=.o)

.PHONY: all clean

all: app enclave.signed.so

######## App Objects ########

App/Enclave_u.c: $(SGX_EDGER8R) Enclave/Enclave.edl
	cd App && $(SGX_EDGER8R) --untrusted ../Enclave/Enclave.edl --search-path ../Enclave --search-path $(SGX_SDK)/include
	@echo "GEN  =>  $@"

App/Enclave_u.o: App/Enclave_u.c
	$(CC) $(App_C_Flags) -c $< -o $@
	@echo "CC   <=  $<"

App/%.o: App/%.cpp
	$(CXX) $(App_Cpp_Flags) -c $< -o $@
	@echo "CXX  <=  $<"

app: App/Enclave_u.o $(App_Cpp_Objects)
	$(CXX) $^ -o $@ $(App_Link_Flags)
	@echo "LINK =>  $@"

######## Enclave Objects ########

Enclave/Enclave_t.c: $(SGX_EDGER8R) Enclave/Enclave.edl
	cd Enclave && $(SGX_EDGER8R) --trusted ../Enclave/Enclave.edl --search-path ../Enclave --search-path $(SGX_SDK)/include
	@echo "GEN  =>  $@"

Enclave/Enclave_t.o: Enclave/Enclave_t.c
	$(CC) $(Enclave_C_Flags) -c $< -o $@
	@echo "CC   <=  $<"

Enclave/%.o: Enclave/%.cpp
	$(CXX) $(Enclave_Cpp_Flags) -c $< -o $@
	@echo "CXX  <=  $<"

enclave.so: Enclave/Enclave_t.o $(Enclave_Cpp_Objects)
	$(CXX) $^ -o $@ $(Enclave_Link_Flags)
	@echo "LINK =>  $@"

enclave.signed.so: enclave.so
	$(SGX_ENCLAVE_SIGNER) sign -key Enclave/Enclave_private.pem -enclave enclave.so -out $@ -config Enclave/Enclave.config.xml
	@echo "SIGN =>  $@"

clean:
	@rm -f app enclave.* $(App_Cpp_Objects) App/Enclave_u.* $(Enclave_Cpp_Objects) Enclave/Enclave_t.*

-------------------

